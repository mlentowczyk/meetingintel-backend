# MEETINGINTEL BACKEND - ALL FILES
# Copy each section below into separate files

# ============================================
# FILE 1: main.py
# ============================================

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
from research_service import generate_meeting_brief
import uvicorn

app = FastAPI(title="MeetingIntel API")

# CORS - allow extension to call API
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify extension ID
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Request models
class Attendee(BaseModel):
    email: str
    name: str

class BriefRequest(BaseModel):
    meeting_id: str
    meeting_title: str
    meeting_time: str
    attendees: List[Attendee]

# Response model
class BriefResponse(BaseModel):
    meeting_id: str
    attendees: List[dict]
    conversation_starters: List[str]
    questions_to_ask: List[str]
    strategy: str
    generated_at: str

@app.get("/")
def read_root():
    return {
        "service": "MeetingIntel API",
        "version": "1.0",
        "status": "active"
    }

@app.post("/api/generate-brief", response_model=BriefResponse)
async def generate_brief(request: BriefRequest):
    """
    Generate meeting brief using Claude AI
    """
    try:
        # Call Claude to research and generate brief
        brief = await generate_meeting_brief(
            meeting_title=request.meeting_title,
            meeting_time=request.meeting_time,
            attendees=[{"email": a.email, "name": a.name} for a in request.attendees]
        )
        
        # Add meeting ID
        brief["meeting_id"] = request.meeting_id
        
        return brief
        
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error generating brief: {str(e)}"
        )

@app.get("/health")
def health_check():
    return {"status": "healthy"}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)


# ============================================
# FILE 2: research_service.py
# ============================================

"""
Research Service - Claude researches attendees and generates meeting briefs
This is where I (Claude) do all the work
"""

import anthropic
import os
from datetime import datetime
from typing import List, Dict

ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY", "")

async def generate_meeting_brief(
    meeting_title: str,
    meeting_time: str,
    attendees: List[Dict[str, str]]
) -> Dict:
    """
    Generate comprehensive meeting brief using Claude + web search
    
    I research each attendee and generate actionable insights
    """
    
    client = anthropic.Anthropic(api_key=ANTHROPIC_API_KEY)
    
    # Build attendee list for prompt
    attendee_info = "\n".join([
        f"- {a['name']} ({a['email']})"
        for a in attendees
    ])
    
    # Research prompt
    prompt = f"""You are a professional meeting preparation assistant. Generate a comprehensive brief for this upcoming meeting:

**Meeting Details:**
- Title: {meeting_title}
- Time: {meeting_time}
- Attendees:
{attendee_info}

**Your Task:**
1. Research each attendee (use web search to find their LinkedIn, recent activity, background)
2. Research the companies they work for (extract domain from email)
3. Generate actionable meeting insights

**Important Guidelines:**
- Focus on ACTIONABLE intelligence (not just facts)
- Provide conversation starters that show you did your homework
- Suggest questions that demonstrate genuine interest
- Be professional but personable

**Output Format (JSON):**
{{
    "attendees": [
        {{
            "name": "...",
            "email": "...",
            "role": "...",
            "company": "...",
            "background": "Brief 2-3 sentence summary",
            "recent_activity": "What they've been posting/doing recently",
            "key_fact": "One interesting fact to mention"
        }}
    ],
    "conversation_starters": [
        "Specific, personalized conversation starter that references their work/interests",
        "Another one...",
        "..."
    ],
    "questions_to_ask": [
        "Thoughtful question about their work",
        "Another...",
        "..."
    ],
    "strategy": "2-3 sentence meeting strategy (what to emphasize, how to position yourself, key themes)",
    "generated_at": "{datetime.now().isoformat()}"
}}

Use web search to find current, accurate information. Be thorough but concise.
"""

    # Call Claude with web search enabled
    try:
        response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=4000,
            tools=[
                {
                    "type": "web_search_20250305",
                    "name": "web_search"
                }
            ],
            messages=[
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        )
        
        # Extract response
        brief_text = ""
        for block in response.content:
            if block.type == "text":
                brief_text += block.text
        
        # Parse JSON response
        import json
        
        # Claude might wrap in ```json blocks
        if "```json" in brief_text:
            json_start = brief_text.find("```json") + 7
            json_end = brief_text.find("```", json_start)
            json_text = brief_text[json_start:json_end].strip()
        elif "```" in brief_text:
            json_start = brief_text.find("```") + 3
            json_end = brief_text.find("```", json_start)
            json_text = brief_text[json_start:json_end].strip()
        else:
            json_text = brief_text.strip()
        
        brief_data = json.loads(json_text)
        return brief_data
        
    except Exception as e:
        print(f"Error generating brief: {e}")
        # Return fallback brief if API fails
        return generate_fallback_brief(attendees)


def generate_fallback_brief(attendees: List[Dict[str, str]]) -> Dict:
    """
    Generate basic brief if API call fails
    """
    return {
        "attendees": [
            {
                "name": a["name"],
                "email": a["email"],
                "role": "Role not yet researched",
                "company": extract_company_from_email(a["email"]),
                "background": "Research in progress...",
                "recent_activity": "",
                "key_fact": ""
            }
            for a in attendees
        ],
        "conversation_starters": [
            "Thank you for taking the time to meet today",
            f"I'm excited to learn more about {extract_company_from_email(attendees[0]['email'])}",
            "What are your top priorities for this quarter?"
        ],
        "questions_to_ask": [
            "What challenges are you currently facing?",
            "What does success look like for you?",
            "How can we best support your goals?"
        ],
        "strategy": "Focus on building rapport, understanding their needs, and exploring potential collaboration opportunities.",
        "generated_at": datetime.now().isoformat()
    }


def extract_company_from_email(email: str) -> str:
    """
    Extract company name from email domain
    """
    try:
        domain = email.split("@")[1]
        company = domain.split(".")[0]
        return company.capitalize()
    except:
        return "Company"


# For testing without API key
async def generate_mock_brief(attendees: List[Dict[str, str]]) -> Dict:
    """
    Mock brief for testing
    """
    return {
        "attendees": [
            {
                "name": attendees[0]["name"],
                "email": attendees[0]["email"],
                "role": "VP of Sales",
                "company": "Acme Corp",
                "background": "10+ years in B2B SaaS sales. Previously led sales at Salesforce for the mid-market segment. Passionate about AI adoption in sales processes.",
                "recent_activity": "Recently posted on LinkedIn about their Q4 results and 2025 strategy",
                "key_fact": "Just completed Stanford Executive Program in AI for Business"
            }
        ],
        "conversation_starters": [
            "I saw your recent post about Q4 results - congratulations on the strong finish! How are you thinking about building on that momentum?",
            "I noticed you completed the Stanford AI program - I'm curious how you're applying those insights to your sales strategy",
            "Your approach to the mid-market segment at Salesforce is really interesting. What lessons are you bringing to Acme?"
        ],
        "questions_to_ask": [
            "What are your top 3 priorities for Q1 2025?",
            "How do you see AI transforming your sales process over the next year?",
            "What challenges are you facing in scaling your sales team?",
            "How do you typically evaluate new tools or partners?"
        ],
        "strategy": "Position as a partner who understands their growth trajectory and can provide ROI-focused solutions. Emphasize speed to value and how you've helped similar companies scale. Ask about their decision timeline and key stakeholders early in the conversation.",
        "generated_at": datetime.now().isoformat()
    }


# ============================================
# FILE 3: requirements.txt
# ============================================

fastapi==0.104.1
uvicorn==0.24.0
anthropic==0.39.0
pydantic==2.5.0
python-multipart==0.0.6


# ============================================
# FILE 4: .gitignore
# ============================================

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Environment variables
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Testing
.pytest_cache/
.coverage
htmlcov/

# Secrets (NEVER commit these)
*.pem
*.key
secrets.json


# ============================================
# DEPLOYMENT INSTRUCTIONS
# ============================================

STEP 1: CREATE FILES
---------------------
Create a new folder called "backend" and inside it create 4 files:
1. main.py (copy code from FILE 1 above)
2. research_service.py (copy code from FILE 2 above)  
3. requirements.txt (copy lines from FILE 3 above)
4. .gitignore (copy from FILE 4 above)

STEP 2: PUSH TO GITHUB
-----------------------
Go to github.com
1. Click "New repository"
2. Name: meetingintel-backend
3. Make it Public
4. Click "Create repository"
5. Click "uploading an existing file"
6. Drag and drop all 4 files
7. Click "Commit changes"

STEP 3: DEPLOY TO RAILWAY
--------------------------
1. Go to railway.app
2. Click "Login with GitHub"
3. Click "New Project"
4. Click "Deploy from GitHub repo"
5. Select "meetingintel-backend"
6. Railway auto-detects Python
7. Click "Deploy"

STEP 4: ADD API KEY
-------------------
1. In Railway dashboard, click "Variables" tab
2. Click "New Variable"
3. Key: ANTHROPIC_API_KEY
4. Value: (your Anthropic API key from console.anthropic.com)
5. Click "Add"
6. Railway redeploys automatically (wait 2 mins)

STEP 5: GET YOUR URL
--------------------
1. Click "Settings" tab in Railway
2. Under "Domains", click "Generate Domain"  
3. Copy the URL (looks like: https://meetingintel-production-XXXX.up.railway.app)
4. SAVE THIS URL - you need it for Chrome extension!

STEP 6: TEST IT
---------------
Open browser and visit:
https://your-railway-url.up.railway.app/health

Should see: {"status":"healthy"}

âœ… BACKEND IS DEPLOYED!

Next: Update Chrome extension background.js with this URL
